module ietf-netconf-tls {

  namespace "urn:ietf:params:xml:ns:yang:ietf-netconf-tls";

  prefix "nctls";

  import ietf-yang-types {
    prefix yang;
  }

  import ietf-netconf-acm {
    prefix nacm;
  }

  organization
   "IETF NETCONF (Network Configuration) Working Group";

  contact
   "WG Web:   <http://tools.ietf.org/wg/netconf/>
    WG List:  <mailto:netconf@ietf.org>

    WG Chair: Mehmet Ersue
              <mailto:mehmet.ersue@nsn.com>

    WG Chair: Bert Wijnen
              <mailto:bertietf@bwijnen.net>

    Editor:   Mohamad Badra
              <mailto:mbadra@gmail.com>

              Alan Luchuk
              <mailto:luchuk@snmp.com>

              Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>";

  description
   "This module applies to NETCONF over TLS.  It specifies how
    NETCONF servers transform X.509 certificates presented by clients
    into NETCONF usernames.  It also specifies how NETCONF servers
    transform pre-shared TLS keys into NETCONF usernames.

    The cert-maps container in this YANG module is patterned after
    parts of the SNMP-TLS-TM-MIB defined in RFC 6353.  Much of the
    description text has been copied directly from the
    SNMP-TLS-TM-MIB, and modified as necessary.
    Copyright (c) 2013 IETF Trust and the persons identified as
    authors of the code. All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, is permitted pursuant to, and subject
    to the license terms contained in, the Simplified BSD
    License set forth in Section 4.c of the IETF Trust's
    Legal Provisions Relating to IETF Documents
    (http://trustee.ietf.org/license-info).

    This version of this YANG module is part of RFC XXXX; see
    the RFC itself for full legal notices.";
  // RFC Ed.: replace XXXX with actual RFC number and
  // remove this note

  // RFC Ed.: please update the date to the date of publication

  revision "2013-02-19" {
    description
     "Initial version";
    reference
     "RFC XXXX: NETCONF over Transport Layer Security (TLS)";
  }

  feature map-certificates {
    description
     "The map-certificates feature indicates that the server
      implements mapping X.509 certificates to NETCONF user names.";
  }

  feature map-pre-shared-keys {
    description
     "The map-pre-shared-keys feature indicates that the server
      implements mapping TLS pre-shared keys to NETCONF user names.";
  }

  // [DISCUSS] This definition of tls-fingerprint is the same as
  //           the one in draft-ietf-netmod-snmp-cfg-01.txt; can
  //           we avoid this duplication?

  typedef tls-fingerprint {
    type yang:hex-string {
      pattern '([0-9a-fA-F]){2}(:([0-9a-fA-F]){2}){0,254}';
    }
    description
     "A fingerprint value that can be used to uniquely reference
      other data of potentially arbitrary length.

      An tls-fingerprint value is composed of a 1-octet hashing
      algorithm identifier followed by the fingerprint value.  The
      octet value encoded is taken from the IANA TLS HashAlgorithm
      Registry (RFC 5246).  The remaining octets are filled using
      the results of the hashing algorithm.

      The corresponding TEXTUAL-CONVENTION allows a zero-length
      value to be used for objects that are optional.  In the YANG
      data models, such objects are represented as optional leafs.";
    reference "SNMP-TLS-TM-MIB.SnmpTLSFingerprint";
  }

  /* Identities */

  // [DISCUSS] The definitions of identities is the same as
  //           the those in draft-ietf-netmod-snmp-cfg-01.txt; can
  //           we avoid this duplication?

  identity cert-to-tm-security-name {
  }

  identity specified {
    base cert-to-tm-security-name;
    reference "SNMP-TLS-TM-MIB.snmpTlstmCertSpecified";
  }

  identity san-rfc822-name {
    base cert-to-tm-security-name;
    reference "SNMP-TLS-TM-MIB.snmpTlstmCertSANRFC822Name";
  }

  identity san-dns-name {
    base cert-to-tm-security-name;
    reference "SNMP-TLS-TM-MIB.snmpTlstmCertSANDNSName";
  }

  identity san-ip-address {
    base cert-to-tm-security-name;
    reference "SNMP-TLS-TM-MIB.snmpTlstmCertSANIpAddress";
  }

  identity san-any {
    base cert-to-tm-security-name;
    reference "SNMP-TLS-TM-MIB.snmpTlstmCertSANAny";
  }

  identity common-name {
    base cert-to-tm-security-name;
    reference "SNMP-TLS-TM-MIB.snmpTlstmCertCommonName";
  }

  container netconf-tls {

    // Objects related to deriving NETCONF usernames from X.509
    // certificates.

    container cert-maps {
      if-feature map-certificates;
      description
       "The cert-maps container is used by a NETCONF server to
        map the NETCONF client's presented X.509 certificate to
        a NETCONF username.

        On an incoming TLS connection, the client's presented
        certificate MUST either be validated based on an established
        trust anchor, or it MUST directly match a fingerprint in the
        'cert-map' list.  This module does not provide any mechanisms
        for configuring the trust anchors; the transfer of any needed
        trusted certificates for certificate chain validation is
        expected to occur through an out-of-band transfer.

        Once the certificate has been found acceptable (either by
        certificate chain validation or directly matching a
        fingerprint in the cert-map list), the cert-map list is
        consulted to determine the appropriate NETCONF username to
        associate with the remote connection.  This is done by
        considering each cert-to-security-name list entry in order.
        The cert-to-security-name entry's fingerprint determines
        whether the list entry is a match for the incoming
        connection:

        1) If the cert-to-security-name list entry's fingerprint
           value matches that of the presented certificate, then
           consider the list entry as a successful match.

        2) If the cert-to-security-name list entry's fingerprint
           value matches that of a locally held copy of a trusted CA
           certificate, and that CA certificate was part of the CA
           certificate chain to the presented certificate, then
           consider the list entry as a successful match.

        Once a matching cert-to-security-name list entry has been
        found, the NETCONF server uses the map-type to determine how
        the NETCONF username associated with the session should be
        determined.  See the map-type leaf's description for details
        on determining the NETCONF username value.  If it is
        impossible to determine a NETCONF username from the
        cert-to-security-name list entry's data combined with the
        data presented in the certificate, then additional
        cert-to-tm-security-name list entries MUST be searched
        looking for another potential match.  If a resulting
        NETCONF username mapped from a given cert-to-security-name
        list entry is not compatible with the needed requirements
        of a NETCONF username, then it MUST be considered an invalid
        match and additional cert-to-security-name list entries MUST
        be searched looking for another potential match.

        If no matching and valid cert-to-security-name list entry can
        be found, then the NETCONF server MUST close the connection,
        and MUST NOT accept NETCONF messages over it.

        Security administrators are encouraged to make use of
        certificates with subjectAltName fields that can be used as
        NETCONF usernames so that a single root CA certificate can
        allow all child certificate's subjectAltName to map directly
        to a NETCONF usernames via a 1:1 transformation.";

      list cert-to-security-name {
        key id;
        description
         "This list defines how certificates are mapped to
          security names.";
        reference "SNMP-TLS-TM-MIB.snmpTlstmCertToTSNEntry";

        leaf id {
          type uint32;
          description
           "The id specifies the order in which the entries in the
            cert-to-security-name container are searched.  Entries
            with lower numbers are searched first.";
          reference "SNMP-TLS-TM-MIB.snmpTlstmCertToTSNID";
        }
        leaf fingerprint {
          type tls-fingerprint;
          mandatory true;
          description
           "Specifies a value with which the fingerprint of the
            certificate presented by the peer is compared.  If the
            fingerprint of the certificate presented by the peer does
            not match the fingerprint configured, then the entry is
            skipped and the search for a match continues.";
          reference "SNMP-TLS-TM-MIB.snmpTlstmCertToTSNFingerprint";
        }
        leaf map-type {
          type identityref {
            base cert-to-tm-security-name;
          }
          mandatory true;
          description
           "Specifies the algorithm used to map the certificate
            presented by the peer to the NETCONF username.

            Mappings that use the snmpTlstmCertToTSNData column
            need to augment the 'cert-to-tm-security-name' list
            with additional configuration objects corresponding
            to the snmpTlstmCertToTSNData value.  Such objects
            should use the 'when' statement to make them
            conditional based on the 'map-type'.";
          reference "SNMP-TLS-TM-MIB.snmpTlstmCertToTSNMapType";
        }
        leaf cert-specified-security-name {
          when "../map-type = 'snmp:specified'";
          type nacm:user-name-type;
          mandatory true;
          description
           "Directly specifies the NETCONF username when the
            'map-type' is 'specified'.";
          reference "SNMP-TLS-TM-MIB.snmpTlstmCertToTSNData";
        }
      }  // list cert-to-security-name
    }    // container cert-maps

   //  Objects related to deriving NETCONF usernames from TLS
   //  pre-shared keys.

   container psk-maps {
     if-feature map-pre-shared-keys;
     description
      "During the TLS Handshake, the client indicates which key to
       use by including a PSK identity in the TLS ClientKeyExchange
       message. On the server side, this PSK identity is used to
       look up an entry in the psk-map list.  If such an entry is
       found, and the pre-shared keys match, then the client is
       authenticated. The server uses the value from the user-name
       leaf in the psk-map list as the NETCONF username.  If the
       server cannot find an entry in the psk-map list, or if the
       pre-shared keys do not match, then the server terminates
       the connection.";
     reference
      "RFC 4279: Pre-Shared Key Ciphersuites for Transport Layer
                 Security (TLS)";
     list psk-map {
       key psk-identity;

       leaf psk-identity {
         type string;
         description
          "The PSK identity encoded as a UTF-8 string. For details on
           how the PSK identity MAY be encoded in UTF-8, see section
           5.1. of RFC 4279.";
         reference
          "RFC 4279: Pre-Shared Key Ciphersuites for Transport Layer
                     Security (TLS)";
       }
       leaf user-name {
         type nacm:user-name-type;
         mandatory true;
         description
          "The NETCONF username associated with this PSK identity.";
       }
       leaf valid-not-before {
         type yang:date-and-time;
         description
          "This PSK identity is not valid before the given data
           and time.";
       }
       leaf valid-not-after {
         type yang:date-and-time;
         description
          "This PSK identity is not valid before the given date
           and time.";
       }
       leaf key {
         type string {
           pattern '([0-9a-fA-F]){2}(:([0-9a-fA-F]){2})*';
         }
         mandatory true;
         nacm:default-deny-all;
         description
          "The key associated with the PSK identity";
       }
     }  // list psk-map
   }  // container psk-maps

  }  // container netconf-tls
}
